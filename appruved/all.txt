ВВЕДЕНИЕ

     В настоящее время рынок информационных технологий активно развивается. Огромные вложения происходят в перспективные проекты, связанные с машинным обучением, решающие задачи как практические, так развлекательные.
     Задачи обнаружения объектов с помощью компьютерного зрения, распознавания тональности человеческой речи, прогнозирования и прочее имеют огромный охват в практическом применении. Подобные проекты постепенно входят в обиход повседневной жизни. Яркими примерами являются камеры с распознаванием лица  в каждом мобильном телефоне, авто-дополнение текста, существующее даже в старых моделях мобильных аппаратов. 
     Одной из актуальных на сегодняшний день является задача семантической сегментации элементов на изображениях. А именно – задача локализации стен на изображениях для последующего взаимодействия, в виде окраски или наложения текстур на распознанные объекты. 
     Применение технологий компьютерного зрения в мобильных приложениях дизайнерской направленности только развивается, рынок полон разнообразных продуктов, представляющих те или иные подходы для решения задачи окраски стен на изображениях. Но, тем не менее, существующее программное обеспечение имеет ряд недостатков, не позволяющих в полной мере использовать данное программное обеспечение для качественной виртуализации окраски стен помещений. Существующие решения обладают узким функционалом или же не доступны для подавляющего круга устройств по техническим причинам. Подобные решения не подходят для профессионального использования, а создание качественного приложения способного в реальном времени сегментировать стены и применять к ним пользовательские текстуры является актуальным для специалистов из сферы дизайна и архитектуры.
     Многофункциональное решение позволит «примерять» различные виды обоев и цветов красок на стены помещений. Что решит проблему неверного выбора цвета в интерьере, сделает более обдуманным и обоснованным принятие решения о выборе того или иного узора обоев для будущего ремонта. А также облегчит составление дизайн-проекта на начальном этапе его проектирования.
     Задача требует решение, способное обнаружить объект в помещении, отнести его к соответствующей группе объектов (объектом может являться стеной, полом, потолком или любым другим предметом интерьера), сегментировать обнаруженный объект, применить выбранный пользователем цвет или текстуру к сегментированному участку изображения.
     Разработка приложения, способного удовлетворить потребности пользователя в проецировании собственных текстур обоев на стены в режиме реального времени не только сделает процесс ремонта более удобным, но и позволит сэкономить на покупке отделочных материалов. 

1	ОБЗОР И АНАЛИЗ ПРОГРАММНЫХ МЕТОДОВ И СРЕДСТВ ДИЗАЙНА ПОМЕЩЕНИЙ

1.1 Задача семантической сегментации изображений интерьеров помещений

     В настоящее время информационные технологии проникают во все сферы деятельности современного общества: от робототехники и медицины, до игр и повседневного быта. В области анализа изображений остаются актуальными такие задачи как: семантическая сегментация классов материала (stuff segmentation) и семантическая сегментация  материалов и классов вещей (panoptic segmentation) [1]. Где вещи – это объекты определенного размера и формы, которые часто состоят из частей, а классы материалов – это фоновые материалы, которые определяются однородными или повторяющимися узорами мелкомасштабных свойств, но не имеют конкретной или отличительной пространственной протяженности или формы [2]. 
     Решения данных задач в последующем применяются не только в области дизайна помещений, но и, например,  для анализа окружающей местности робототехникой, в медицинской визуализации, спутниковой съемке, и другом.
     Задача распознавания фона, а именно стен в интерьерах помещений, является задачей семантической сегментации материала.
     В задачах семантической сегментации каждому пикселю изображения присваивается метка, определяющая принадлежность пикселя к классу. Подобный подход позволяет не просто понять примерную область расположения объекта в кадре, а очертить контур объекта.
     На рисунке 1.1 представлены виды распознавания объектов на изображениях.
     


Рисунок 1.1 – Виды распознавания объектов на изображениях
     
     Семантическая сегментация – это задача присвоения семантической метки, такой как «дорога», «небо», «человек», «собака», каждому пикселю изображения.
     Назначение семантических меток требует точного определения контура объектов и, таким образом, предъявляет гораздо более строгие требования к точности локализации, чем другие задачи распознавания визуальных объектов, такие как классификация на уровне изображения или обнаружение на уровне ограничивающего прямоугольника.
     Инстанс-сегментация – в отличие от семантической сегментации, выделяет каждый объект внутри класса отдельным сегментом.
     Паноптическая сегментация – объединяет задачи семантической и инстанс-сегментации. Также в задаче паноптической сегментации каждому пикселю изображения должна быть присвоена ровно одна метка.
     Распознавание стен на кадрах и последующая замена их цвета и текстуры решаемо семантической сегментацией на уровне типа объекта.

1.2 Нейронные сети для обработки изображений интерьеров помещений

     1.2.1 В настоящее время проводится огромное количество исследований посвящённых созданию новых моделей нейронных сетей, для решения задач семантической сегментации интерьеров помещений в том числе. 
     Модели нейронных сетей, созданных для сегментации, разделяют на кодировщик и декодер, где кодеры обычно модифицируются непосредственно из сетей классификации, а декодеры состоят из окончательных сверток и повышающей дискретизации [3].  
     Задача распознавания стен относится к задачам Indoor Object Segmentation и Scene Segmentation.
     При выборе конкретных кодера и декодера был проведён анализ и сравнены общие характеристики моделей. Из числа моделей, показывающих хорошие результаты в качестве сегментации, можно выделить кодировщик ResNet(50/101) в связке с декодером PPM_deepsup. Хорошие характеристики скорости распознавания имеет кодировщик MobileNetV2dilated в связке с декодером C1_deepsup.
     В таблице 1.1 представлены характеристики архитектур кодировщика и декодера.
     
     Таблица 1.1 – Характеристики ResNet и MobileNet
Архитектура
mloU
Pixel Accuracy 
Общий балл
Скорость (кадры/сек)
MobileNetV2dilated +
34.84
75.75%
54.07
17.2
C1_deepsup
33.84
76.80%
55.32
12.3
ResNet50dilated +
41.26
79.73%
60.50
8.3
PPM_deepsup
42.14
80.13%
61.14
2.6
      Mean Intersection over Union (mIoU) – измеряет общее количество пикселей между целевой и прогнозной масками, деленное на общее количество пикселей, присутствующих в обеих масках [4]. Метрика показывает насколько два объекта, эталонный и текущий, совпадают по границам.
     Pixel Accuracy – cостоит в том, чтобы просто сообщить процент пикселей в изображении, которые были правильно классифицированы.
     Описанные характеристики в таблице выше являются удовлетворительными для решаемой задачи, а выбранные модели нейронных сетей достаточно распространёнными.
       
     1.2.2 Данные, на которых была обучена сеть имеют важную роль. Количество хороших наборов данных ограничено сложностью нормализации данных. А в случае с задачей сегментации, также и созданием дополнительной разметки на изображениях. 
     COCO (Common Objects in Context) – это крупномасштабный набор данных для задач обнаружения и сегментации [5]. Данный набор данных содержит как изображения интерьеров помещений, так и экстерьеров, городских ландшафтов.
     COCO имеет несколько функций:
– сегментация объекта;
– признание в контексте;
– сегментация пиксельного материала;
– 330000 изображений (помечено > 200000);
– 1,5 миллиона экземпляров объектов;
– 80 категорий объектов.
     ADE20K – это крупнейший набор данных с открытым исходным кодом для семантической сегментации и анализа сцены помещения, выпущенный командой MIT Computer Vision [6].
     ADE20K состоит из изображений из баз данных SUN и Places. Изображения полностью аннотированы объектами. Многие изображения также содержат части объектов и под-части объектов. Изображения анонимны – лица и номерные знаки размываются. Всего для оценки включено 150 семантических категорий, которые включают такие вещи, как небо, дорога, трава, стена, потолок и дискретные объекты, такие как человек, машина, кровать, стол и другие. 
     Последняя версия набора данных содержит:
     – 27574 изображения (25574 для обучения и 2000 для тестирования), охватывающих 365 различных сцен;
     – 707868 уникальных объектов из 3688 категорий, а также их определение и иерархия WordNet;
     – 193238 аннотированных частей и под-частей объектов;
     – Аннотации многоугольников с атрибутами, временем аннотации, порядком глубины. 
     На рисунке 1.2 отражено несколько примеров из набора данных ADE20K.


Рисунок 1.2 – Пример изображений набора данных ADE20K

     Исходя из рисунка 1.2, можно сделать вывод, что данный набор отлично подходит для нейронной сети, решающей задачу сегментации стен. ADE20K содержит, преимущественно изображения интерьера помещений, а аннотированные его части включают в себя локализацию стен.
    Для сравнения производительности и общей эффективности в решении задачи сегментации стен взяты обученные нейронные сети следующих архитектур: кодировщик MobileNetV2dilated и декодер C1_deepsup, обученные на данных из набора ADE20K, для мобильного устройства, кодировщик Resnet50dilated и декодер  ppm_deepsup, обученные на данных из набора ADE20K, для персонального компьютера.

1.3 Современное программное обеспечение подборки цвета и текстуры обоев для стен помещения

     1.3.1 На сегодняшний день существуют технологии, позволяющие использовать мобильные устройства для проецирования на фотографию или видео в реальном режиме времени виртуальных текстур, предметов и другого. Например, технология дополненной реальности широко применяется для решения подобных задач. А машинное обучение, в свою очередь, обеспечивает точность в локализации необходимых объектов или распознавание ключевых точек на изображении для последующего качественного проецирования объекта.
     Рынок программного обеспечения богат на разнообразные решения, способные обеспечить «примерку» обоев, ламината, предметов мебели, как на интерьер пользователя, так и на виртуальные интерьеры. Данные решения, в большинстве, представляют мобильные и веб приложения. Подавляющее большинство программного обеспечения не может похвастать возможностью проецирования виртуальных объектов в режиме реального времени или, как минимум, проецирования на интерьер пользователя, что существенно обесценивает их как решения.
     В таблице 1.2 представлены примеры существующих приложений, имеющих в том или ином виде функционал, способный подбирать и изменять текстуру и цвет обоев для финишной отделки помещения.
     
     Таблица 1.2 – Существующие решения для подборки цвета и текстуры обоев
Программное обеспечение
Разработчик
Страна разработки
Петрович: товары для стройки и ремонта
Petrovich
Российская Федерация
3D шоурум
Petrovich
Российская Федерация
Виртуальная комната
Интернет-магазин «Обои в дом»
Беларусь
Примерка обоев
Интернет-магазин «Обои в дом»
Беларусь
Paint Tester
Luminant Software, Inc.
США
MyRoomPainter
Crown Paints
США
Dulux Visualizer
AkzoNobel
Великобритания
ColorSnap Visualizer
Sherwin-Williams
США
Nippon Paint Colour Visualizer
Nippon Paint Singapore Co Pte Ltd
США
Paint Harmony
Cambrian Mixed Reality
США

     Такие сервисы, как «Петрович: товары для стройки и ремонта», «3D шоурум», «Виртуальная комната», «Примерка обоев», «Paint Tester», «MyRoomPainter», «Dulux Visualizer», «Nippon Paint Colour Visualizer», «ColorSnap Visualizer»,  и «Paint Harmony» решают задачу подбора обоев и цвета для стен.
     Представленные приложения продолжают поддерживаться и активно развиваться, что может дать шанс на появление в будущем большего количества возможностей у представленного программного обеспечения. 
     Ниже представлены описания, а также разбор достоинств и недостатков приложений из списка, достойных внимания и имеющих оригинальные функции. 
     Виртуальная примерочная обоев, от одноимённого производителя строительных материалов «Петрович» [7], может менять вид квартиры с помощью мобильного устройства. Мобильное приложение обладает функционалом, позволяющим фотографировать помещение и заменять на сделанных фотографиях обои, выбирая последние из представленного каталога. То есть, с помощью смартфона, можно примерить любые обои, с рисунками или без, к своим родным стенам.
     На рисунке 1.3 представлены снимки пользовательского интерфейса приложения.



Рисунок 1.3 – Интерфейс мобильного приложения «Петрович» 

     Помимо фотографирования собственного интерьера, имеется уже существующий каталог готовых фотографий различных помещений, поделённых на категории: гостинная, спальня, кабинет, кухня, ванная, прихожая, детская и другие. Подобный функционал позволяет выбрать готовый снимок, который больше всего похож на квартиру пользователя и примерить обои к выбранной виртуальной комнате.
     К преимуществам данного решения можно отнести возможность изменять стены на реальных фотографиях, достаточно большой каталог обоев и качественную реализацию.
     Недостатками приложения «Петрович» можно считать отсутствие режима работы приложения в реальном времени, отсутствие возможности создавать собственные фото обоев и применять их.
     Приложение сильно завязано на продукции одноимённого производителя, что ухудшает его универсальность и гибкость.
     Помимо мобильного приложения производитель «Петрович» имеет веб версию с похожим функционалом.
     Веб версия приложения носит название 3D шоурум. Отличительной чертой данной разработки является возможность перемещения по виртуальному пространству комнаты, что позволяет рассмотреть вид под разными углами.
     На изображении 1.4 представлен внешний вид веб приложения 3D шоурум.
     


Рисунок 1.4 – Интерфейс мобильного приложения 3D шоурум

     Идея виртуальной комнаты является довольно распространённой среди торговых площадок, специализирующихся на продаже мебели, материалов и прочих вещей домашнего обихода.
     Ещё одним представителем списка подобных площадок является интернет-магазин «Обои в дом». Помимо непосредственного каталога материалов, он предоставляет следующие возможности: примерка обоев в виртуальной комнате, примерка обоев по вашей фотографии, выбор обоев на примерах реализованных интерфейсов [8].
     	Виртуальная комната представлена в двухмерном виде, не имеет возможности изменять углы обзора, но выполняет свою изначальную функцию – обеспечивает подстановку любых обоев из предоставленного каталога.
     Виртуальная комната магазина «Обои в дом» имеет несколько видов помещений, в том числе для гостинной, кухни, спальни, коридора и детской. А также представляет два вида интерьера: классический и современный.
     Ещё одним сервисом, предоставленным магазином «Обои в дом», является сервис «Примерка обоев». Отличительная черта данного сервиса – отсутствие специализированного программного обеспечения. Подстановка выбранных пользователем обоев осуществляется специалистами и дизайнерами магазина «Обои в дом» и в течении рабочего дня предоставляется пользователю.
     Данный сервис выигрывает у конкурентов за счёт точности определения стен на фотографии и осознанной консультации специалистов по подбору цвета и типа обоев. Сервис «Примерка обоев» требует соблюдение следующих правил:
* хорошее освещение предоставляемой фотографии;
* размер фотографии не менее тысячи пикселей;
* прямой или боковой ракурс на фотографии.
     К фотографии следует приложить документ с информацией о размере помещения (длина/ширина, высота стен), номера артикулов понравившихся обоев или ссылки на страницы с обоями (не более трёх артикулов, а при комбинировании обоев не более трёх пар). Далее изображение и документ отправляется на почту сайта.
     Как итог дизайнеры магазина «Обои в дом» предоставят готовые изображения с видом выбранных обоев на интерьере покупателя, а также предложат альтернативные варианты дизайн-решений.
     На рисунке 1.5 показан результат работы данного сервиса.
     


Рисунок 1.5 – Результат работы сервиса «Примерка обоев» магазина «Обои в дом»

     Среди мобильных приложений по подборке цвета стен можно выделить Paint Tester. Это бесплатное приложение позволяющее "прикинуть" цветовую гамму, которая лучше всего подойдет помещению пользователя. 
     Работа с приложением осуществляется в три шага:
* фотографирование помещения или его части в нужном ракурсе;
* добавление фото в приложение;
* выбор цвета.
     Приложение имеет два инструмента: "Кисть" и  "Заливка". Первый позволяет "точечно" закрасить помещение и детали интерьера, а второй – полностью закрашивает элементы помещения одинакового цвета и фактуры. 
     Результат можно сохранить или поделиться им в соцсетях, а также передать посредством беспроводных сетей (Bluetooth, ИК-порт и т.д.).
     Программка подходит всем, кто собирается сделать ремонт или начинающим дизайнерам.
     На рисунке 1.6 можно увидеть интерфейс и результат работы приложения Paint Tester.


Рисунок 1.6 – Интерфейс мобильного приложения Paint Tester

     К плюсам приложения Paint Tester можно отнести его мобильность, возможность редактировать представленный вариант заливки и возможность делиться результатом.
     Явными минусами являются: отсутствие возможности использования текстур для заливки стен, низкое качество локализации стен на изображениях,  отсутствие поддержки специализированного магазина. 
     Отсутствие интеграции с производителем  лишает пользователя возможности приобрести краску подобранного цвета через данное приложение.
     	Более функциональным в сравнении с Paint Tester является мобильное приложение MyRoomPainter. MyRoomPainter оформлено как богатый и функциональный сайт. Благодаря ему можно нужный тон помещению. 
     В отличие от "покрасочной" ориентации Paint Tester, данная утилита содержит готовые заготовки фактурных цветов.
     Мобильное приложение Paint Harmony использует достаточно хороший алгоритм локализации стен и пола в помещении.  Выбранный цвет ложится точно в пределах стены или иной части интерьера. 
     Приложение имеет функцию ластика, а также  различные настройки корректировки яркости, контраста и глубины цвета, в том числе и регулировки прозрачности. 
     Мобильное приложение Dulux Visualizer [9] – одно из наиболее привлекательных приложений представленного выше списка.
     С помощью приложения Dulux Visualizer можно оценить различные идеи покраски, для того, чтобы найти идеальную цветовую палитру.
     Возможности приложения Dulux Visualizer:
     * режим реального времени для проецирования цветовых палитр на стену с помощью технологии дополненной реальности;
     * распознавание и выделение ключевых оттенков окружающей среды для последующего применения в работе с приложением;
* интеграция с производителем Dulux.
     Для того чтобы приложение смогло перекрашивать ваши стены в режиме реального времени, использующее мобильное устройство должно быть оснащено датчиками движения. Далеко не все устройства оборудованы подобной технологией, что оставляет таким устройствам для использования одну функцию – фото, чтобы отобразить цвета на статичном изображении вашей комнаты.
     Интерфейс приложения Dulux Visualizer и качество локализации стены представлены на рисунке 1.7.



Рисунок 1.7 – Интерфейс мобильного приложения Dulux Visualizer

     Новейшая версия приложения ColorSnap Visualizer для мобильных устройств объединяет возможности дополненной реальности под названием Instant Paint [10]. Эта функция обеспечивает быстрый и удобный способ визуализации любого из тысячи пятисот цветов на стенах, как в режиме реального времени, так и на фото. Приложение использует палитры цветов бренда Sherwin-Williams.
     Плюсами данного приложения являются: качественный функционал, хороший интерфейс, точная сегментация стен, возможность выбирать необходимые для покраски участки, сотрудничество с компанией-производителем краски.
     Минусом является поддержка ограниченным количеством устройств. Так как для использования функции распознавания стен и последующей их покраски в режиме реального времени необходима поддержка последней версии ARCore мобильным устройством.
     Интерфейс приложения ColorSnap Visualizer и качество локализации стены представлены на рисунке 1.8.
  

Рисунок 1.8 – Интерфейс приложения ColorSnap Visualizer

     Мобильное приложение Nippon Paint Colour Visualizer является виртуальным художником, который помогает сделать работу по оформлению помещений проще [11]. Приложение обеспечивает работу в режиме реального времени, позволяет выбирать цветовые палитры из имеющегося набора.
     Отличительной особенностью приложения является функция сохранения тени и текстуры при сегментации и окраски стены. Это позволяет сформировать реальное представление о внешнем виде стен после покраски. 
Приложение использует цветовой каталог производителя Nippon. Ещё одной особенностью приложения является самостоятельный подбор цвета для интерьера, основанный на гамме загруженного изображения.
    Единственным обнаруженным минусом приложения является использование устаревших возможностей языка java для импорта изображений, что в ряде случаев не корректно отображает загруженное изображение на интерфейсе пользователя.
      
     1.3.2 Алгоритмы решающие задачу сегментации элементов на изображениях, как правило, основаны на нейронных сетях или общих математических методах компьютерного зрения без использования нейронных сетей.
     В некоторых случаях, для распознавания объекта, достаточно программного обеспечения, но в ряде других необходимо подключать к работе иные технические средства. Рассматривая область мобильных приложений, можно заметить, что некоторые приложения используют возможности камеры устройства для улучшения результатов распознавания. 
     Существует два основных варианта решения программным путём задачи сегментации стен на плоских изображениях. Первый – обученная нейронная сеть, второй – алгоритмы компьютерного зрения без использования нейронных сетей. 
     Задачи сегментации хорошо решаемы с помощью глубоких свёрточных нейронных сетей использующих архитектуру кодера и декодера [12]. Существует достаточное число решений в области сегментации объектов интерьера, в том числе и стен, нейронными сетями.
     Со стороны решения математическими методами без использования нейронных сетей существует проблема в небольшом количестве особенных характеристик и признаков распознаваемого объекта, что усложняет его локализацию. В данном случае, локализация стен может быть осуществлена стандартными методами обработки контуров. Достаточное число математических методов в реализованном виде можно найти в библиотеке компьютерного зрения OpenCv [13].
     Исходя из анализа существующего программного обеспечения, можно сделать вывод – наиболее конкурентоспособным приложением будет приложение, имеющее следующие функции:
* поддержка локализации стен в режиме реального времени;
* достаточная точность распознавания стен;
* разнообразие цветовых палитр;
* возможность применять текстуры, как встроенные, так и сторонние;
* возможность экспорта изображений;
     * использование цветов или текстур реальных продуктов (которые можно в последующем приобрести).
     Рассмотренные приложения не достаточно качественно решают существующую проблему – окраску стен в реальном времени. Приложения, что предоставляют подобную функцию, поддерживаются не всеми устройствами, за счёт используемых технологий. Так же нет ни одного приложения способного в реальном времени проецировать выбранные пользователем обои на стену.
     Мобильное приложение, которое предоставит пользователю необходимый функционал, и возможности отсутствующие у конкурентов, такие как: использование текстур для заливки стен, режим реального времени, поддержка на любом современном мобильном устройстве, стабильность в работе – конкурентоспособно и является надёжным инструментом, как для дизайнеров интерьеров, так и для пользователей планирующих ремонт. 
     Исходными данными, в случае с мобильным приложением, выступает видео ряд или одиночное изображение, выходом является, соответственно обработанный видеоряд (с сегментированными окрашенными стенами) или изображение. 
     Так как предполагается поддержка режима реального времени, алгоритм сегментации стен должен выдавать приемлемую скорость обработки изображения, которая предполагает не менее двенадцати кадров в секунду. Данное значение используется в мультипликации и хорошо воспринимается человеческим глазом. Верхний предел скорости обработки поступающих кадров не обозначен и определяется лишь самим алгоритмом сегментации и техническими характеристиками мобильного устройства.
     Разработка конкурентоспособного мобильного приложения для подбора цвета и текстур обоев для финишной отделки помещения требует следующих этапов:
     * создание алгоритма локализации стен на основе методов компьютерного зрения без использования нейронной сети;
     * применение обученной нейронной сети для задачи сегментации стен, её валидация и последующее сравнение результатов с методами компьютерного зрения без использования нейронных сетей;
     * разработка мобильного приложения способного использовать алгоритмы, как с нейронной сетью, так и без для обработки входящих изображений;
     * создание алгоритма окраски и наложения текстур на сегменты изображения;
     * валидация и верификация используемых алгоритмов за счёт вывода результатов работы на графический интерфейс мобильного приложения.
     Исходя из обзоров и выводов в предыдущих пунктах, стек технологий для разработки мобильного приложения следующий: java, OpenCv, Pytorch. 
     Разработка мобильного приложения на языке программирования java, является самым тривиальным из имеющихся вариантов, но также самым богатым на количество примеров и обучающего материала.
     OpenCv – одна из лучших библиотек компьютерного зрения, обладающая развитым функционалом и обширной документацией на русском языке. Библиотека имеет методы, которые хорошо подойдут для предварительной обработки изображения. Данная библиотека станет инструментом для решения задачи локализации стен методами компьютерного зрения без использования нейронных сетей. 
    Библиотека Pytorch для машинного обучения является гибким профессиональным инструментом по созданию моделей нейронных сетей. Подавляющее большинство хороших нейронных сетей для сегментации элементов в помещениях, смоделировано и обучено с использованием данной библиотеки.


82	АРХИТЕКТУРА ПОРТОВ И АДАПТЕРОВ ПРОГРАММНОГО КОМПЛЕКСА «WALLSDETECTER»

2.1 Основные функции программного комплекса «WallsDetecter»

     Разрабатываемое мобильное приложение – «WallsDetecter», должно решать одну основную задачу: окрас стены на изображении. Дополнениями данной задачи являются:  режим реального времени, возможность выбора цвета окрашивания, возможность окрашивания текстурами.
     Основная задача включает в себя две составляющих: локализация и сегментация стены на изображении, окрашивание той части изображения, что была обозначена как стена.
     Из обзора сегментации – известно, что каждому пикселю изображения, в данном случае, присваивается метка класса, следовательно, результат работы первой функции это массив значений размером с число пикселей изображения, в котором пиксели, распознанные как стена, обозначены одним значением, а остальное – другим. Подобный массив является своеобразной маской. 
     Входными же данными первой функции будет исходное изображение, также представленное в виде массива.
     Вторая функция, функция окраса, должна принимать результат работы первой – маску, исходное изображение и желаемый цвет. Данная функция вернёт уже окрашенное изображение также в виде массива.
     Две вышеописанные функции выступают в виде первостепенных бизнес правил. Остальной функционал станет дополнением к бизнес логике.
     В дополнительный функционал входит:
* графический вывод результата;
* импорт изображения из галереи;
* захват изображения через камеру;
* дополнительная постобработка маски.
     Если функция окраски использует функционал библиотеки компьютерного зрения, то функция локализации стен на изображениях совмещает два разных подхода к решению задачи локализации и сегментации стен: 
* локализация стен методами компьютерного зрения без нейронных сетей;
* локализация и сегментация стен с помощью нейронной сети. 
     Подобный функционал позволит провести исследование и сравнительный анализ локализации стен обоими методами, а также даст пользователю возможность выбирать, какой из методов использовать при эксплуатации приложения. 
     Для достижения наилучшей точности сегментации и достаточной скорости обработки изображений, непосредственно, алгоритмы решающие данную задачу должны быть расположены на машине с соответствующими техническими характеристиками. Мобильные устройства по производительности проигрывают персональным компьютерам с хорошей сборкой. Учитывая данный факт, исследование качества сегментации нейронными сетями и без них дополняется исследованием скорости сегментации. В последнем примут участие три алгоритма: 
* нейронная сеть;
* облегчённая нейронная сеть для мобильных устройств;
* методы компьютерного зрения без нейронной сети.
     На изображении 2.1 показана общая схема проектирования проектируемого программного обеспечения.



Рисунок 2.1 – Визуализация основных функций приложения

     Пунктирным подчёркиванием на схеме указано направления потока управления. 
     В сносках указаны подфункции двух главных функций приложения. Подфункции 1.1, 1.2 и 1.3 подлежат сравнению по скорости обработки данных, а также по качеству выходного результата.
     Нейронные сети с облегченной архитектурой более быстрые, но заведомо выдают менее точный результат. Для реализации качественной сегментации стен основной алгоритм не должен располагаться на мобильном устройстве. Здесь существует несколько подходов: реализация стороннего сервиса локально на персональном компьютере (доступ по локальной сети) или хостинг разработанного серверного API (Application Programming Interface)  на удалённую машину (и доступ по глобальной сети интернет).
     В обоих случаях мобильное приложение становится клиентом, и должно реализовывать сетевые программные интерфейсы.
     На рисунке 2.2 приведена схема структуры программного комплекса с указанным распределением выполняемых задач.
     

     
Рисунок 2.2 – Клиент серверное разграничение задач в программном комплексе
     
     Как видно из схемы, вся бизнес логика, связанная с обработкой изображения, была вынесена на сервер. 
     Мобильное приложение получает исходное изображение из вне, отправляет его и дополнительные параметры на сервер по сети, ожидает результирующего  изображения от сервера.

2.2 Архитектура компонентов программного комплекса «WallsDetecter»

     Исходя из лучших практик проектирования архитектуры программного обеспечения, важно выделить несколько ключевых факторов, которые объединяют хорошо спроектированное программное обеспечение: минимизация связности написанного кода, разграничение компонентов программного обеспечения по типам решаемых задач и целям изменения, разграничение деталей и бизнес правил.
     Для выполнения первого правила, из перечисления представленного выше, следует ввести и активно использовать в программном коде интерфейсы, а также направить все имеющиеся зависимости в сторону созданных интерфейсов.
     Выполнение второго правила преследует цель уменьшить количество затронутых функций для внесения каких либо дополнений в будущем.
     Для выполнения третьего правила следует выделить алгоритмы непосредственно решающие задачу от стороннего программного обеспечения, такого как пользовательский интерфейс, ввод, вывод данных, хранение данных, сетевое взаимодействие.
     Также важно выделить – все детали должны зависеть от бизнес правил.
          
     2.2.1  На основе описанных выше выводов составлена схема взаимодействия компонентов приложения между собой для клиента (рисунок 2.3).
     


Рисунок 2.3 – Компоненты клиентского приложения
     
     Так как клиент не имеет ключевой бизнес логики все второстепенные задачи, а именно прикладные бизнес правила, находятся в классах самого представления.
     Помимо представления клиент имеет детали реализации, такие как:
* ресурсы представления (файлы разметки графического интерфейса);
* класс асинхронных задач;
* библиотека сетевого взаимодействия.
     Специфика Android приложения подразумевает использование фрагментов и рабочих окон, как своеобразных контроллеров. Внешний вид интерфейса описывается независимо и находится в отдельных файлах.
     Класс асинхронных задач подразумевает наличие в приложении тяжеловесных задач, таких как сетевое взаимодействие, тяжёлые вычисления, обращение к сторонним источникам, и их взаимодействие с пользовательским интерфейсом. Из перечисленного мобильный клиент использует сетевое взаимодействие, а также импорт и экспорт изображений из локального хранилища мобильного устройства, что обязывает использовать асинхронные операции или многопоточность.
     Библиотека сетевого взаимодействия включает классы, реализующие сетевой интерфейс. Библиотека предназначена для обмена изображениями и метаданными с сервером.
     На изображении 2.4 представлен более детальный вид архитектуры мобильного приложения, включающий разделение на компоненты, классы и интерфейсы.


Рисунок 2.4 – Архитектура клиентского приложения

     Поток исполнения представлен пунктирной стрелкой.
     Логика взаимодействия пользователя с интерфейсом приложения располагается в рабочих окнах (ключевых компонентах для системы Android). Более глубокие специфические бизнес правила расположены во фрагментах, относящихся к одному из рабочих окон.
     Разрабатываемый мобильный клиент имеет два рабочих окна. Первое – это окно экрана подключения к серверу. В нём происходит соединение с сервером, при успехе которого, управление передаётся основному рабочему окну приложения. Основное рабочее окно отвечает за такие операции, как отключение от сервера, установку дополнительных параметров, выбор типа взаимодействия с сервером. 
     Типы взаимодействия с сервером отражены во фрагментах приложения. 
     Первый фрагмент – фрагмент изображения, включает в себя всё необходимое для импорта изображения, отправки его на сервер и получения исходного результата также в виде изображения.
     Второй фрагмент мобильного приложения – фрагмент видео, включает в себя операции захвата видео ряда в режиме реального времени, транслирования кадров по сети на сервер и получение результирующих кадров, а также их отображение на пользовательском интерфейсе.
     Класс сетевого взаимодействия используется всеми реализованными фрагментами и рабочими окнами, что лишает смысла составлять сетевые интерфейсы на их стороне. Наилучшим решением является применение шаблона SingleTone к данному классу, что фактически, сделает из него глобальную переменную, а связь с другими классами – ассоциативной.
     Для классов асинхронных задач применена композиция, как связь взаимодействия с классами. Каждое рабочее окно или фрагмент содержит внутренний класс, реализующий именно те асинхронные задачи, что необходимы для каждого конкретного рабочего окна или фрагмента.
          
     2.2.2 На основе описанных в начале главы выводов по архитектуре, составлена схема взаимодействия компонентов приложения между собой для сервера (рисунок 2.5).


     
Рисунок 2.5 – Компоненты серверного приложения
     
     Архитектура сервера разделена на три основных блока: бизнес правила уровня решаемой задачи, прикладные бизнес правила, фреймворки и драйверы.
     Бизнес правилами уровня решаемой задачи выступают две главные функции – сегментации изображения и окраски изображения. 
     Роль прикладных бизнес правил играет логика обработки того или иного варианта поведения серверного приложения, в зависимости от выбранного типа взаимодействия клиентом: обработка изображений или обработка видео ряда.
     Фреймворками и драйверами в данном случае выступают классы графического вывода и сетевого взаимодействия.
     Класс сетевого взаимодействия абстрагирован от классов бизнес логики, так как для решения поставленной задачи не имеет значения тип получения и передачи данных, следовательно, сетевая часть приложения лишь деталь реализации.
     Данные модули описывают все функциональные особенности разрабатываемого приложения.

2.3  Модель потоков данных программного комплекса «WallsDetecter»

	Модель потоков данных используются при предварительном проектировании, для отслеживания потоков данных, с целью на раннем этапе выявить недостатки системы.
     На изображении 2.6 представлена модель потоков данных для клиентского приложения системы окраски стен.



Рисунок 2.6 – Модель потоков данных клиентского приложения

     Как видно из диаграммы 2.6, клиентское приложение состоит из двух основных процессов: нормализации полученного из внешнего источника изображения и его отправки.
     В режиме работы без реального времени пользователь указывает цвет, или выбирает текстуру, а затем выбирает изображение, к которому необходимо применить выбранные цвет или текстуру.
     Клиентское приложение обладает тремя источниками данных:
* камера мобильного устройства;
* внутреннее хранилище мобильного устройства;
* результирующее изображение с сервера.
     Соответственно, для отправки на сервер можно выбрать изображение из одного из трёх источников.
     Перед отправкой изображение проходит процесс нормализации, а затем нормализованное изображение и указанный пользователем цвет передаются на сервер по сети. При этом сервер возвращает результирующее изображение, которое можно пере-отправить снова.
     Процесс отправки изображения преобразовывает данные в массив байт, с который будет преобразован обратно на стороне сервера. 
     На рисунке 2.7 представлена модель потоков данных для серверного приложения системы окраски стен.



Рисунок 2.7 – Модель потоков данных серверного приложения
     
     Клиент отправляет на сервер два вида данных – это изображение и цвет или текстуру, в которую необходимо окрасить стены на изображении. 
     Сервер состоит из двух основных процессов – процесс сегментации изображения (здесь может быть как алгоритм с нейронной сетью, так и алгоритм без нейронной сети) и процесс окраски изображения. 
     Процесс сегментирования изображения принимает на вход результирующее изображение, а отдаёт на выходе изображение-маску. 
     Процесс окраски изображения принимает маску и исходное изображение и отдаёт результирующее изображение, которое следующим этапом доставляется пользователю.
     Если рассматривать представленную выше диаграмму в более крупном масштабе, можно выделить составляющие процесса сегментации изображения. На рисунке 2.8 представлена декомпозиция процесса сегментации изображения с использованием нейронной сети.
     


Рисунок 2.8 – Модель потоков данных процесса сегментации изображения
     
     Как видно из рисунка выше, процесс сегментации изображения состоит из трёх основных частей. 
     Первый процесс нормализует входное изображение для последующей передачи в нейронную сеть.
     Второй и третий процессы являются составляющими нейронной сети. Данные процессы представляют обученную модель нейронной сети, и состоят из определённого числа слоёв. Данные, между которыми, переходят в виде многомерных массивов, а каждый новый слой дополняет результат предыдущего.
     Второй процесс предназначен для выделения из изображения всех необходимых признаков (модель кодировщика). 
     Третий процесс преобразовывает полученные признаки в сегментированное изображение (модель декодера). 
     На выходе образуется изображение с той же размерностью, что и исходное, но представляющее из себя маску помещения. То есть то, что является ключевым объектом помещения (стена, пол, потолок, предметы интерьера), окрашено в соответствующий классу цвет.
     На рисунке 2.9 представлена декомпозиция процесса окрашивания изображения.
     


Рисунок 2.9 – Модель потоков данных процесса окрашивания изображения
     
     Процесс окраски изображения получает три типа входных данных: исходное изображение, цвет или текстуру и маску помещения. 
     Первым из внутренних процессов является нормализация маски – данный процесс выделяет из всех сегментированных объектов помещения именно стену. Следующим шагом окрашивает маску в необходимый цвет и добавляет альфа-канал (прозрачность) к изображению-маске. 
     Следующий процесс принимает изображение-маску стены и исходное изображение. Данный процесс объединяет полученные данные в одно результирующее изображение.

     
     
     
223	СТРУКТУРА ПРОГРАММНОГО КОМПЛЕКСА «WALLSDETECTER»

3.1 Локализация стен методами компьютерного зрения без использования нейронных сетей

     В настоящем проекте библиотека OpenCV решает задачи обработки изображения, а также поиска и классификации на нём прямолинейных контуров. OpenCV имеет ряд полезных методов для решения задачи нахождения контуров.
     Обработка входного изображения производится в несколько этапов, каждый из которых, отдаёт результат собственной работы следующему. Принцип конвейерной ленты позволяет добиться наилучшего результата. Гибкость архитектуры позволяет менять местами или добавлять новые методы обработки, тем самым облегчая разработку.
     Первый этап представляет первичную обработку изображения и создание маски над ним. Затем следует функция поиска контуров (findContours) библиотеки OpenCV, что определяет контур объектов на изображении, основываясь на градиентах граничных частей. Основой для первого этапа является изображение, обработанное методом Canny библиотеки OpenCV. Canny – метод обнаружения края элементов на изображении. Является многоэтапным алгоритмом. На первом этапе алгоритма происходит подавление шума методом Гаусса. Так как обнаружение контуров чувствительно к шуму. Дальше следует нахождение интенсивности изображения за счёт фильтрации ядром Собеля по вертикали и по горизонтали. Этот же этап включает нахождение градиента. На выходе образуется чёрно-белое контурное изображение.
     Второй этап подразумевает работу непосредственно с самими контурами. На данном этапе происходит отсеивание небольших объектов путём вычисления площадей их контуров. Здесь среднее арифметическое показывает преимущество над медианным средним за счёт достаточного числа небольших шумовых объектов на изображении.
     Третий этап работает непосредственно с найденными контурами. На данном этапе идёт сокращение ключевых точек контуров и последующая аппроксимация. Контур приобретает чёткую форму, лишаясь незначительных искривлений.
     Четвёртый этап включает функции сортировки контуров на вертикальные и горизонтальные, с учётом отклонения от нормали, а также нахождения точек пересечения двух типов контурных линий. На данном этапе используется функция преобразования Хафа. Преобразование Хафа – вычислительный алгоритм, применяемый для параметрической идентификации геометрических элементов растрового изображения. Чтобы применить преобразование, сначала желательна предварительная обработка края. Для преобразований Хафа линии выражаются в полярной системе координат. В общем случае линию можно обнаружить, определив количество пересечений между кривыми. Чем больше пересекающихся кривых, тем больше точек на линии, представленной этим пересечением. Общий случай даёт возможность определить порог минимального количества пересечений, необходимых для обнаружения линии.
     На рисунке 3.1 отображены этапы обработки изображения алгоритмом без нейронной сети.
  
  

Рисунок 3.1 – Этапы обработки изображения алгоритмом без нейронной сети
  
     Найденное очертание области графически отображаются на исходном изображении и выводятся пользователю.
     Программное обеспечение выполняет задачу распознавания плоскостей на изображениях. Система создана с использованием технологии компьютерного зрения. Распознавание плоскостей на фотографиях является первым этапом в построении системы обнаружения и замены части изображения, в данном случае стены. Потенциально данный инструмент способен облегчить работу дизайнеров интерьера при подборе цветовой гаммы.
     Как результат – математические методы без использования нейронных сетей хорошо справляются с точностью определения контуров искомых плоскостей, но не способны отличить стены от других поверхностей, что является существенным недостатком. 

3.2 Локализация стен обученной нейронной сетью

     Для работы с нейронной сетью использовалась библиотека PyTorch. За основу взяты модели архитектуры нейронных сетей MobileNet и ResNet, реализовано переключение между ними.
     Скрипт работы с нейронной сетью разбит на несколько секций.
     Первая секция – загрузка предварительно сохранённых кодера и декодера. Они и являются основными составляющими обученной нейронной сети и содержат в себе весовые значения.
     Далее следует секция объединения кодера и декодера в сегментационный модуль а также переключение модели в режим тестирования методом eval.
     Следующая часть скрипта посвящена предварительной обработке изображения:
     – изменение до размера трёхсот десяти пикселей по большей стороне;
     – конвертация в формат RGB (Red Green Blue);
     – нормализация с помощью параметров std и mean (рекомендуемые документацией Pytorch параметры, представляющие из себя массивы чисел);
     – преобразование в массив и создание тензора на основе данного массива.
     После происходит вызов нейронной сети с флагом no_grad – отключение градиентов.
     Завершающая секция производит обратное изменение размера сегментированной маски до изначального размера входного изображения.
     Вариант с изменением исходного изображения, прежде чем отправить его в нейронную сеть, использован для увеличения скорости обработки. Обратное увеличение полученной маски до исходного размера приводит к пикселизации контура, как видно из изображения 3.2, но данный нюанс решается постобработкой.
     


Рисунок 3.2 – Контур сегментационной маски
     
     На рисунке 3.3 представлены этапы обработки изображения: сегментирование изображения нейронной сетью, постобработка полученной маски.



Рисунок 3.3 – Этапы обработки изображения алгоритмом с нейронной сетью 
     Постобработка результирующего изображения состоит в выделении на сегментированном изображении только маски стены (в примере на изображении 3.3 она представлена серым цветом). Затем маске присваивается выбранный пользователем цвет или текстура, дальше на небольшой процент увеличивается прозрачность. После чего массив представляющий маску объединяется с массивом, представляющим исходное изображение. Перечисленные операции выполняются с помощью библиотеки numpy.
     Для достижения эстетически приемлемого результата выходной маске также нужна пост обработка в виде сглаживания контуров. Данная проблема также решаема методами библиотеки компьютерного зрения OpenCv и библиотеки numpy.
     
3.3  Структура и алгоритмы на стороне серверного программного обеспечения

     Для применения результатов сегментации кадров в реальных условиях было создано два приложения: сервер и мобильный клиент. 
     Серверное приложение разворачивается на персональном компьютере пользователя – ПК. Для автоматической загрузки необходимых библиотек и удобной сборки проекта на java использовался инструмент maven. Файл pom.xml содержит настройки сборки проекта и объявления, необходимых для работы проекта, библиотек.
     Сервер принимает поступающие от клиента изображения, пробрасывает их через нейронную сеть и возвращает исходный результат клиенту.
     Оба приложения используют язык программирования java.
     После принятия файла с клиентского приложения сервер передаёт его на обработку python скрипту, работающему с нейронной сетью либо python скрипту, работающему с алгоритмами компьютерного зрения, не использующими нейронную сеть. Полученное результирующее изображение отправляется обратно клиенту. 
     Использование скрипта на языке python, как компонента, для решения основной задачи сервера связано с лёгкостью внесения дополнительных изменений в код, без необходимости перезапускать или перекомпилировать сервер.
     Серверное приложение содержит: 
     – класс сетевого взаимодействия протокола TCP/IP (Server);
     – класс работы с изображениями, в том числе их чтением и записью (ImgHelper);
     – обученные модели кодера и декодера, нейронных сетей mobilenet и resnet50, решающих задачу локализации стен на изображениях (decoder_epoch_20.pth, encoder_epoch_20.pth);
     – скрипт на языке Python для взаимодействия с нейронными сетями;
     – скрипт на языке Python, содержащий алгоритмы компьютерного зрения без использования нейронных сетей;
     – класс взаимодействия со скриптами на языке Python (PyHelper);
     – класс запуска серверного приложения (Main).
     Класс Main  содержит одноимённый метод и вызывает метод Start класса Server. 
     Класс ImgHelper содержит методы работы с изображениями, такие как SaveImg и ReadImg, которые отвечают за сохранение и считывание файла изображения из дискового пространства.
     Для работы с python-скриптом был создан класс PyHelper, имеющий единственный метод CallPy. Метод работает с классами Process и Runtime.
     В классе Server находятся методы, обрабатывающие входящие подключения от двух типов клиентов. Элементы, находящиеся в классе Server можно увидеть в таблице 3.1.

     Таблица 3.1 – Элементы класса Server
Имя
Вид элемента
Тип
Модификатор доступа
Краткое описание
SERVER_PORT
Переменная
static final int
public
Хранит значение порта подключения
BUFER_SIZE
Переменная
static final int
private
Хранит значение размера буфера
WorkWithFirstClientType
Метод
void
private
Работает с типом клиента, сегментирующим изображения
WorkWithSecondClientType
Метод
Void
private
Работает с типом клиента, сегментирующим кадры видео ряда
Start
Метод
void
public
Обрабатывает входящие подключения
      
     В методе Start сервер запускает свою работу, начинает обрабатывать входящие подключения от клиентов до тех пор, пока не будет вручную остановлен. 
     После запуска сервер становится в позицию ожидания подключений. Приложение поддерживает многопользовательский режим, за счёт выделения отдельного потока работы для каждого пользователя. После принятия подключения клиента сервер выделяет ему отдельный поток, в котором обрабатывает все его запросы, а в основном потоке продолжает ожидать следующие подключения.
     Сервер имеет консольное отображение информации, преимущественно используемое для отладки и тестирования.
     Для подключения клиента к серверу необходимо указать IP-адрес (Internet Protocol Address) и порт. Порт задан постоянной переменной и не изменим при каждом новом запуске. 
     Существует несколько вариантов узнать IP-адрес ПК. Одним из представительных решений может оказаться широковещательная рассылка. Более простой способ – использовать статический IP, который можно узнать, вписав команду ipconfig в консоль (Windows).
     После установки связи клиент обязан сообщить свой тип серверу. Первый тип клиента отвечает за сегментацию изображений и фотографий, второй – за сегментацию кадров видео ряда. Каждый клиент обрабатывается в новом потоке, что позволяет серверу обрабатывать запросы сразу нескольких клиентских приложений.
     Для передачи информации по сети используется класс ServerSocket и его методы Accept, GetInputStream, GetOutputStream и Close. Для обработки входящих данных типа byte а также их отправки обратно на клиент используются классы DataInputStream и DataOutputStream соответственно. Вышеупомянутые классы являются наследниками классов BufferedInputStream BufferedOutputStream, а те в свою очередь, наследуются от InputStream и OutputStream. Каждое поколение классов имеет своё преимущество. Задачи, решаемые разрабатываемым приложением, не требуют низкоуровнего вмешательства в работу сетевого взаимодействия, благодаря чему можно использовать уже готовые методы для работы со строками, числами и массивами данных типа byte. 
     Класс Server имеет два метода для обработки работы двух типов клиентов: WorkWithFirstClientType и WorkWithSecondClientType.
     Подробная работа алгоритма метода WorkWithFirstClientType описана ниже.
     Работа с изображениями осуществляется посредством класса BufferedImage. Объект класса BufferedImage сериализуется в массив байт для отправки клиенту осуществляется с помощью класса ImageIO и его метода Write, который принимает ByteArrayOutputStream и записывает в него изображение, представленное BufferedImage. Затем объект ByteArrayOutputStream преобразовывается в массив байт.
     При передаче изображения клиент, сперва отправляет размерность передаваемого массива байт, а затем, отправляет сам массив, который на стороне сервера принимается порционно.
     Существует несколько подходов реализации отправки крупных данных по сети. Первый подразумевает одно подключение для одной передачи. То есть, как только файл, изображение, видео или другой документ были переданы, соединение закрывается. Этот способ надёжен, так как при разрыве соединения серверу, считывающему данные, приходит значение-ключ, обозначающее разрыв соединения, который является и сигналом к завершению передачи файла. Минусом данного подхода является неэкономное использование ресурсов. Второй подход – использовать суррогатный ключ завершения передачи, без разрыва самой связи. Минусом данного способа является сложность составления достаточно надёжного ключа, который бы не совпал с передаваемой частью данных. А также необходимость постоянного отслеживания появления данного ключа от принимающей стороны.
     Ещё одним способом является первичная передача данных о размере последующего передаваемого файла принимающей стороне. Плюсом данного способа является относительно несложная реализация и отсутствие разрыва соединения.
     Последний способ наиболее подходит для реализации передачи изображений или кадров клиентом. Так как разрывать подключение между передачей первого и второго кадра видео ряда не удачное решение в виду экономии времени пользователя и ресурсов памяти.
     Метод принимает размер будущего изображения, далее происходит считывание входящего потока и запись их порциями в OutputStream до тех пор, пока размер считанного массива не достигнет заявленного размера клиентом. Затем OutputStream с помощью метода ToByteArray переводится в массив байт.
     Изображения передаются пакетами размерностью с буфер конкретного приложения, как на серверном, так и на клиентском программном обеспечении (далее ПО), значение буфера выставлено в 2048 байт. Число выбрано как компромисс между скоростью передачи данных и вероятностью их потери.
     Несмотря на размер буфера, размер реально передаваемых данных может отличаться как в большую, так и в меньшую сторону. Данное поведение обусловлено возможными помехами в сетевом взаимодействии и нестабильностью сетевого сигнала в целом.
     Вышеупомянутое поведение выставляет ограничение на использование точного подсчёта порций передаваемых данных. Но данная проблема решается используемым механизмом передачи больших файлов.
     
3.4  Структура и алгоритмы на стороне клиентского программного обеспечения

     Мобильное приложение подразумевает несколько вариантов использования: сегментирование отдельных изображений, сегментирование кадров с камеры в реальном режиме времени. В зависимости от выбранного варианта, сервер будет обрабатывать одни и те же запросы по-разному. 
     Платформа разработки мобильного клиента – Android, как одна из самых распространённых мобильных операционных систем. Язык программирования – java. 
     Клиентское приложение содержит: 
     – класс сетевого взаимодействия протокола TCP/IP (MobSocket);
     – классы двух основных экранов приложения (MainActivity и WorkActivity);
     – классы фрагментов приложения (VideoFragment и PictureFragment);
     – класс работы с Camera API (MobCameraAPI);
     – ресурсы разметки пользовательского интерфейса (activity_main.xml, activity_work.xml, fragment_picture.xml и fragment_video.xml).
     Приложение имеет два основных окна: окно подключения (MainActivity), которое состоит из двух полей для ввода параметров подключения и кнопки «connect», и рабочее окно (WorkActivity), которое становится доступным после успешного подключения к серверу. 
     В таблице 3.2 отображены элементы класса MainActivity разрабатываемого мобильного приложения.
     
     Таблица 3.2 – Элементы класса MainActivity
Имя
Вид элемента
Тип
Модификатор доступа
Краткое описание
b_enter
Переменная
Button
private
Кнопка устанавливающая соединение
port
Переменная
EditText
private
Поле ввода порта для подключения
ip
Переменная
EditText
private
Поле ввода IP адреса для подключения
onCreate
Метод
void
protected
Обрабатывает событие нажатия на кнопку установки соединения
MobTask
Вложенный класс
AsyncTask
private
Специализированный класс асинхронных задач

     Как только пользователь ввёл все необходимые данные для подключения и нажал соответствующую кнопку, создаётся новый экземпляр асинхронного класса MobTask, который является наследником базового класса AsynkTask. MobTask является вложенным классом MainActivity, и не доступен для кода из вне.
     В классе MobTask создаётся сокет подключения, принимается сообщение от сервера, подтверждающее успешность подключения и возвращается результат операции в виде булевого значения.
     Выполнять масштабные операции в основном потоке, работающем с пользовательским интерфейсом, не является хорошей практикой. Операции, такие как: работа с сетью или с базой данных, могут отнимать достаточно большое количество времени. Выполнение подобных операция в основном потоке заблокирует на время их исполнения отклик пользовательского интерфейса. Со стороны пользователя данное явление выглядит как зависание программы. Это может негативно сказаться на пользовательском опыте. Избежать подобной ситуации можно используя потоки или асинхронное программирование.
     Существует ограничение – параллельным потокам запрещён доступ к элементам управления. И если от результата исполнения тяжёлой операции зависит представление пользовательского интерфейса, уместней использовать класс, разработанный специально для подобных нужд – AsynkTask. Он является абстрактным и требует собственной реализации от разработчика. 
     Основными методами класса AsynkTask можно назвать: doInBackground (в нём необходимо реализовать код тяжёлой операции), onPostExecute и onPreExecute (методы, исполняющиеся до и после операции, в основном потоке, то есть имеющие доступ к интерфейсу пользователя). Конструктор AsynkTask принимает на вход неограниченное число параметров заданного в объявлении класса типа. Также можно задать типы параметров, возвращаемых при завершении операции или при промежуточных выводах.
     Выше описанные составляющие доказывают удобство использования методов данного класса для решения задач с сетевым соединением. 
     Во время подключения в MainActivity  создается сокет подключения, позволяющий обмениваться данными между устройствами. Класс, отвечающий за сетевое соединение – MobSoket.
     Задача передачи сокета между Activity решается паттерном SingleTone. Такое решение заменяет глобальную переменную, а также ограничивает создание новых экземпляров класса без необходимости.  
     Класс MobSoket, помимо реализации SingleTone, имеет шесть основных рабочих методов, не считая перегрузки: connectToDevice, unconnectToDevice, sendMessage , getMessage SendFile и GetFile.
     В методе connectToDevice вызывается метод Connect  у объекта сокета. Метод unconnectToDevice закрывает все открытые соединения, в том числе и те, что были использованы для передачи или получения данных. 
     Метод sendMessage создаёт или использует объект класса DataOutputStream, используемый для отправки сообщения на сервер. И непосредственно отправляет сообщение на сервер.
     Метод getMessage создаёт или использует объект класса DataInputStream, используемый для получения сообщения от сервера в строковом формате. 
     Также есть два подобных вышеописанным метода SendFile и GetFile. Они предназначены для отправки объёмных сообщений, как правило, файлов, а в контексте настоящего приложения – изображений. Методы работают с массивом байт и содержат логику характерную для отправки или принятия объёмного объекта.
     После успешного подключения к серверу происходит переход на экран WorkActivity, который располагает тремя кнопками: «unconnect», «picture» и «realtime_video». 
     Кнопка «unconnect» отправляет на сервер числовое значение ноль, что является признаком завершения сеанса с пользователем. Следующим действием разрывает соединение, вызывая метод Unconnect класса MobSocket, который закрывает выходящий и исходящий потоки, а затем и сам сокет. Клиентское же приложение снова переходит в окно подключения. Подобное мягкое решение разрыва связи создано для обеспечения возможности серверу корректно завершить работу с данным клиентом и обработкой его данных.
     Первым вариантом использования мобильного клиента является – передача изображений. Импортировать изображение можно выбрав из галереи настоящего устройства или сделав снимок. Клиент предназначен для разового анализа. Удобен в обработке изображений, сделанных в прошлом, и не требователен к качеству связи и техническим характеристикам мобильного устройства.
     Второй тип клиента отвечает за передачу кадров видео, а именно трансляцию последнего на сервер в реальном времени. Ответ от сервера поступает также в реальном времени и выводится на экран приложения. 
     Кнопки «picture» и «realtime_video» отвечают за тип клиента, при их нажатии происходит отправка на сервер сообщения с номером типа клиента, а также создаётся и отображается соответствующий фрагмент. Для определения типа фрагмента использован фабричный метод, возвращающий необходимый класс, по числу. Для выполнения операций по отправки сообщений на сервер создан вложенный класс ClientTypeTask, наследующий AsynkTask. Он принимает входным значением число, идентифицирующее тип клиента. Отправляет его значение на сервер и, в случае успешной отправки, создаёт и открывает соответствующий фрагмент.
     Приложение имеет два класса фрагментов: FragmentPicture и FragmentVideo.
     FragmentPicture содержит кнопки, отвечающие за импорт и отправку на сервер изображений: «upload photo», «send photo». А также объект ImageView, отвечающий за отображение исходного или результирующего изображения на экране мобильного приложения для пользователя. В таблице 3.3 описаны основные компоненты класса FragmentPicture.
     
     Таблица 3.3 – Основные элементы класса FragmentPicture
Имя
Вид элемента
Тип
Модификатор доступа
Краткое описание
mobSocket
Переменная
MobSocket
private
Класс сетевого взаимодействия
     Продолжение таблицы 3.3
selectImage
Метод
void
private
Контекстное меню импорта изображений
onActivityResult
Метод
void
public
Логика обработки импортированного изображения
onCreateView
Метод
View
public
Содержит логику обработки нажатий кнопок, расположенных во фрагменте
ControllerTask
Вложенный класс
AsyncTask
private
Специализированный класс асинхронных задач

     Класс FragmentPicture содержит вложенный асинхронный класс – ControllerTask. Его задачей является асинхронный вызов метода отправки файла, класса MobSocket. При нажатии управляющей кнопки, создаётся новый объект класса ControllerTask.
     Сервер работает с изображениями формата jpeg или jpg (название на старых платформах, не поддерживающих формат файла больше трёх символов). Соответственно при импорте из галереи файл конвертируется в необходимый формат перед преобразованием в массив байт. При создании фото – изображения имеют необходимый формат по умолчанию.
     После нажатия на кнопку импорт изображения перед пользователем появляется диалоговое окно со списком отзывчивых элементов: Take Photo, Choose from Gallery, Cancel.
     После выбора изображение передаётся элементу отображения на экране.
     Обработанное изображение снова отображается в элементе ImageView.
32
4	ВЕРИФИКАЦИЯ И ОПЫТНАЯ ЭКСПЛУАТАЦИЯ РАЗРАБОТАННОГО ПРОГРАММНОГО КОМПЛЕКСА

4.1 Интерфейс пользователя программного комплекса

     На рисунке 4.1 приведён граф вариантов взаимодействия с мобильным клиентом, который описывает функциональное назначение разработанного программного средства, взаимоотношение и зависимости между группами вариантов использования и пользователем.
     

     
Рисунок 4.1 – Граф вариантов взаимодействия с клиентским приложением
     
     Варианты использования пользовательского интерфейса разработанного мобильного клиента полностью отражают доступный для изменения функционал разработанного сервера.
     Как видно из графа выше, взаимодействие с клиентским мобильным приложением состоит из нескольких этапов:
     * соединение с сервером (подразумевает ввод необходимых IP-адреса и порта);
     * конфигурация параметров; 
     * установка цвета либо текстуры (цвет задаётся кодом в формате трёх цветовой модели RGB, текстура выбирается из имеющихся фотографий на мобильном устройстве или через снимок фотокамеры);
     * установка изображения (если не включён режим реального времени);
     * запрос отправки данных на сервер;
     * получение результата (результат в виде сегментированного окрашенного изображения будет отражён на пользовательском интерфейсе мобильного клиента).
     В этап конфигурации параметров входит:
     * выбор типа скрипта (нейронная сеть с архитектурой ResNet50, нейронная сеть с архитектурой MobileNet или скрипт с компьютерным зрением без нейронной сети);
     * выбор типа клиента (режим реального времени или режим изображений);
     * дополнительные параметры (размер изображения поданного на вход нейронной сети и другие отладочные коэффициенты).
     Если этап конфигурации параметров (кроме выбора типа клиента) был пропущен – параметры останутся заданными по умолчанию, но есть возможность их изменить в любой момент времени через кнопку «меню» приложения.
     Граф для варианта использования пользовательского интерфейса разработанного мобильного приложения в режиме реального времени отображён на рисунке 4.2.


     
Рисунок 4.2 – Граф вариантов взаимодействия с клиентским приложением в режиме реального времени
     
     Как видно из графа выше – кадры захватываются сразу из камеры мобильного устройства и непрерывно отправляются на сервер, так же как и результат с сервера непрерывно возвращается на клиентское мобильное приложение и отражается на экране графического интерфейса.
     В сравнении с графом вариантов использования в режиме без реального времени, граф с режимом реального времени значительно меньше.
     Преимуществами данного режима, помимо очевидных, также является изменение цвета или текстуры «на ходу», то есть без остановки транслирования кадров на сервер. Для этого достаточно выбрать из графической панели «Выбор цвета» другой цвет или текстуру и нажать на соответствующее изображение.
     На рисунке 4.3 представлены снимки экранов мобильного приложения «WallsDetecter».
     
  
     
Рисунок 4.3 – Основные рабочие окна мобильного приложения «WallsDetecter»

     Слева на рисунке 4.3 изображено окно подключения. Если подключение прошло успешно, экран перейдёт в рабочую область. Часть рабочей области выделена под отображение рабочих окон. Она является пустой до тех пор, пока не будет выбран тип клиента, нажатием одной из двух соответствующих клавиш. 
     Кнопка «unconnected» отвечает за отключение клиента. Если тип клиента не был выбран, но кнопка «unconnected» нажата – сервер закончит работу с безымянным клиентом и перейдёт в режим прослушивания новых подключений.
     После выбора типа клиента, на сервер будет отправлено соответствующее сообщение, а приложение откроет один из двух фрагментов: для отправки фотографий или для работы в режиме реального времени.
     Тип клиента выбирается нажатием одной из двух кнопок «picture» или «realtime video».
     Клик по кнопке «realtime video» приводит к отображению экрана с камерой и нижней панели инструментов. Нижняя панель инструментов  содержит стандартные цвета и несколько стандартных текстур. Отправка и отображение полученного результата с сервера в данном варианте использования происходит автоматически. Таким образом, пользователь может наблюдать за локализацией и окрашиванием стен в реальном времени, а также менять цвет или текстуру окраски в любой момент, не прерывая работу приложения.
     Клик по кнопке «picture» приводит к отображению экрана с областью отображения картинки и с двумя кнопками: импорт и отправка изображения.  Клик по кнопке «upload photo» в данном экране открывает панель выбора вариантов загрузки изображения. Здесь пользователь может загрузить готовое изображение из галереи или сделать снимок нового. На рисунке 4.3 (по центру) отображён вид экрана со списком выбора действий для импорта изображения.
     Нажатие на кнопку «send photo» отправляет изображение на сервер, где происходит дальнейшая обработка. Результат обработки расположен на рисунке 4.3 справа.
     В зависимости от размера отправляемого изображения время обработки может варьироваться. Также данный показатель зависит и от качества соединения, которое, в свою очередь, влияет на скорость передачи данных.
     Графический интерфейс пользователя со стороны сервера ограничен консольным выводом. На консоль выводятся в основном логи, отражающие происходящие на данный момент работы сервера события, и дополнительные параметры.
     На рисунке 4.4 представлен серверный консольный интерфейс после запуска.
     


Рисунок 4.4 – Консольный интерфейс серверного приложения при запуске
     
     Сервер начинает работу с отображения в консольном окне IP-адреса, на котором он запущен, и порта. Сервер прослушивает любые подключения из вне, находящиеся в той же локальной сети, что и он сам.
     На рисунке 4.5 представлен один цикл принятия, обработки и отправки обратно изображения от первого типа клиента.



Рисунок 4.5 – Цикл работы сервера с первым типом клиента
     
     Подключение и отключение клиента также регистрируются выводом на консоль информации о типе клиента. На рисунке выше отражено подключение первого типа клиента, получение сервером размерности передаваемого изображения, строка загрузки изображения. Где первое число – количество полученный байт за текущую итерацию, второе число – количество принятых байт всего, третья число – необходимое количество байт, которое совпадает с размерностью изображения. 
     Дальше следует запуск скрипта и отображение его ошибок, если таковые имели место быть. После подсчитывается размер обработанного изображения, после чего, то отправляется обратно клиенту.
     Завершение работы символизируется значением ноль, после получения которого сервер прекращает работу с данным клиентом.

4.2  Отладка и валидация результатов работы программного комплекса

     Для отслеживания корректности передаваемых данных и общих процессов в целом, как в мобильном приложении, так и в серверном предусмотрена текстовая отчётность хода передачи. На сервере логирование происходит с выводом на консольный интерфейс. Мобильное приложение записывает происходящие процессы как в лог-файл, так и выводит на консоль.
     Пример логов при подключении к серверу и отправке типа клиента представлен на рисунке 4.6. 



Рисунок 4.6 – Вывод логов при подключении к серверу

     Для отображения происходящих операций, логи представлены до и после создания объекта подключения. Так же регистрируется создание и работа объектов классов, ответственных за отправление и приём сообщений. 
     На изображении 4.7 представлены логи, выводящиеся при завершении работы с сервером.



Рисунок 4.7 – Вывод логов при отключении от сервера

     Логирование помогает отследить места происхождения ошибок или предотвратить их возможное появление, а также наладить стабильность и  корректность работы системы приложений.
     Программный комплекс построен таким образом, что на каждом этапе работы с изображением или кадром можно получить текущее состояние последнего. Данный метод отлично подходит для систем, работающих с графической информацией, что позволяет точно определить качество работы методов, и при необходимости, скорректировать параметры. 
     На рисунке 4.8 представлена модель потоков данных серверного приложения с отображением ключевых состояний исходного графического образца.


     Рисунок 4.8 – Модель потоков данных серверного приложения с ключевыми состояниями исходного графического образца

     Ключевые состояния сегментируемого, а затем, окрашиваемого изображения отмечены цифрами во временной очерёдности. 
     На вход системы подаётся исходное изображение (на рисунке 4.8 отмечено единицей) и цвет (в конкретном рассматриваемом случае). На исходном изображении, прошедшем через этап сегментирования, выделяется маска основных областей изображения (стены, двери, потолок, пол, растения) – на рисунке 4.8 выделено номером два. Далее, этап окраски выделяет маску стены (номер три на рисунке 4.8), добавляет к ней альфа канал и совмещает с исходным изображением. Результат возвращается пользователю (номер четыре на рисунке 4.8).
     Таким образом, система подбора цвета и текстуры обоев для финишной отделки помещения справляется с поставленной задачей, а именно, даёт пользователю возможность экстраполировать будущий внешний вид помещения, при выбранном цвете краски для стен или орнаменте обоев, за счёт выявления стен на изображении и подстановки соответствующего цвета или текстуры.
     Также программный комплекс обладает рядом функциональных дополнений, таких как возможность корректировки точности и качества распознавания стен и поддержка режима реального времени.
     
4.3  Результаты сегментации изображений программным комплексом «WallsDetecter»
     
     Для исследования качества сегментации стен на изображениях было проведено несколько экспериментов между тремя алгоритмами, решающими данную задачу:
     * нейронная сеть с архитектурой ResNet50;
     * нейронная сеть с архитектурой MobileNet;
     * методы компьютерного зрения без нейронных сетей.
     Первый эксперимент включает в себя замер времени работы алгоритмов при входном изображении размерностью 1000 пикселей, 510 пикселей, 360 пикселей, 310 пикселей и 220 пикселей. Второй эксперимент заключается в сравнении качества сегментации трёх алгоритмов при заданных выше значениях размерности входных изображений.
     В таблице А.1 представлены средние показатели времени исполнения каждого из трёх алгоритмов в секундах, при разных размерностях входных изображений. Как видно из А.1 нейронная сеть с архитектурой ResNet50 исполняется значительно дольше остальных алгоритмов. Использование подобной архитектуры для сегментации в реальном времени – затруднительно. 
     Нейронная сеть с архитектурой MobileNet, в свою очередь, показывает лучшие результаты времени выполнения, но при этом, также не выдаёт скорость близкую к 0,0833 секундам (которая могла бы обеспечить обработку двенадцати кадров  секунду). MobileNet архитектура хорошо подходит для мобильных устройств за счёт значительно большей скорости обработки кадров. Для обработки кадров в режиме реального времени архитектура MobileNet имеет преимущество над ResNet50.
     Алгоритм без нейронной сети работает значительно быстрее алгоритмов с нейронными сетями и отлично подходит для использования в режиме реального времени. 
     Качество сегментации изображений измеряется двумя метриками: Mean Intersection over Union (mloU) и Pixel Accuracy. Первая метрика показывает насколько текущее изображение маски сегментации совпадает по границам с эталонным изображением маски сегментации. Вторая метрика сообщает процент правильно сегментированных пикселей.
     В таблице А.2 представлены значения метрик mloU, Pixel Accuracy и результирующего бала для каждого алгоритма с учётом зависимости размера входящего изображения. Эталонное изображение маски сегментации приводилось к соответствующей размерности исходного изображения маски сегментации для корректных результатов сравнения.
     В таблице 4.1 представлены результирующие показатели для каждого из алгоритмов.
     Таблица 4.1 – Характеристики архитектур ResNet, MobileNet и алгоритма без нейронной сети
Архитектура
mloU
Pixel Accuracy 
Общий балл
Скорость (кадры/сек)
ResNet50
0,796
0,842
0,819
0,1
MobileNet
0,763
0,899
0,831
0,312
Без нейронной сети
0,335
0,442
0,389
31,25

     На рисунке 4.9 представлен график зависимости скорости работы (слева)  и общего оценочного балла (справа) от качества входного изображения для каждого из трёх алгоритмов.
     
 

Рисунок 4.9 – Зависимость времени работы и качества сегментации алгоритмов от размерности входного изображения соответственно

     Как видно из графика на рисунке 4.9 (слева), нейронная сеть с архитектурой ResNet50 стремительно увеличивает время обработки после размерности изображения в 500 пикселей по одной из диагоналей. Изображение размерностью в 1000 пикселей обрабатывается данной архитектурой 30 секунд, что крайне долгий результат для использования вне исследовательских целей. 
     На графике на изображении 4.9 (справа) присутствуют два пересечения алгоритмов с нейронными сетями – на начальной размерности изображения в 220 пикселей и на размерности в 800 пикселей. То есть, при размерности входного изображения в 300 пикселей, алгоритм с облегченной нейронной сетью (MobileNet) выдаёт лучший результат сегментации, чем алгоритм ResNet50.
     На изображении 4.10 наглядно представлены результаты сегментации одного изображения в пяти разных размерностях моделями нейронных сетей ResNet50 и MobileNet, а также алгоритмом компьютерного зрения без использования нейронной сети соответственно.
     


Рисунок 4.10 – Результат сегментации стен алгоритмами компьютерного зрения при различных размерах входного изображения

     По результатам сегментации на рисунке 4.10 можно сделать вывод, что архитектура ResNet50 более точно  сегментирует стены на изображении, в сравнении с двумя другими алгоритмами.
     Архитектура MobileNet имеет достаточно неровные очертания контуров сегментированной области. Но на максимальной представленной размерности изображения, архитектура выдаёт результат сравнимый с качеством сегментации ResNet50. 
     Алгоритм без нейронной сети на больших изображениях выдаёт ровные очертания контуров. Но при этом, алгоритм компьютерного зрения без нейронной сети показал наихудшие результаты по сегментации стен, в сравнении с алгоритмами, использующими нейронные сети.
     Работа алгоритмов нейронных сетей и алгоритма компьютерного зрения без нейронной сети была протестирована на нескольких типах изображений. 
     Результаты работы нейронных сетей оказались более качественными в сравнении с результатами работы алгоритма без использования нейронной сети. Как вывод – нейронные сети, в сравнении с алгоритмом без нейронной сети, показали более точный результат сегментации изображений. 
43
5 ЭКОНОМИЧЕСКОЕ ОБОСНОВАНИЕ ДИПЛОМНОЙ РАБОТЫ

5.1 Обоснование целесообразности разработки программного 
      продукта 

Мобильное приложение подборки цвета и текстуры обоев для финишной отделки приложения позволяет пользователям примерять» различные виды обоев и цветов красок на стены помещений. Принятие решения о выборе того или иного цвета для будущего ремонта с использованием данного приложения более обдуманно и обосновано.
Мобильное приложение подборки цвета и текстуры обоев может заинтересовать полиграфические компании, а также предприятия по производству материалов покраски, облицовки, обоев. 
Для компании-владельца экономическая выгода заключается в размещении ссылок на собственный товар внутри приложения, таким образом пользователи смогут купить товар именно марки компании-владельца. Размещение ссылок на товар в мобильном приложении открывает новый путь для рекламы и сбыта товара. Также в приложение может быть встроена контекстная реклама.
Программа является ещё одним хорошим инструментом, облегчающим выбор и помогающим в работе в конкретной области. А именно – точная оценка сочетаемости предметов интерьера без необходимости строить 3д модель помещения.
В первую очередь приложение нацелено на архитекторов, дизайнеров, художников и людей, желающих сделать ремонт в квартире самостоятельно.
	Рынок имеет конкурентоспособные аналоги, но данный продукт обладает рядом отличительных преимуществ. К преимуществам программного продукта можно отнести встроенный режим работы в реальном времени, и широкий спектр поддерживаемых устройств.

5.2 Оценка конкурентоспособности программного обеспечения 

Техническая прогрессивность разрабатываемого программного продукта определяется коэффициентом эквивалентности () [14]. Расчет этого коэффициента осуществляется путем сравнения технического уровня товара-конкурента и разрабатываемого программного продукта по отношению к эталонному уровню программного продукта данного направления с использованием формулы (5.1):


(5.1)

где ,– коэффициенты технического уровня нового и базисного программного продукта, которые можно рассчитать по формуле (5.2): 


(5.2)

где	β – коэффициенты весомости i-го технического параметра;
n – число параметров;
 – численное значение i-го технического параметра, сравниваемого программного продукта;
 – численное значение i-го технического параметра эталона.
Расчет коэффициента эквивалентности приведен в таблице Б.1.
Полученное значение коэффициента эквивалентности больше единицы, следовательно, разрабатываемый программный продукт является технически прогрессивным.
Далее рассчитывается коэффициент изменения функциональных возможностей () нового программного продукта по формуле (5.3):


(5.3)

где ,  – балльная оценка неизмеримых показателей нового и базового изделия соответственно.
	Расчет коэффициента изменения функциональных возможностей нового программного продукта приведен в таблице Б.2.
Коэффициент функциональных возможностей превышает единицу т.е. новый программный продукт превосходит по своим функциональным возможностям базовый в 1,42 раза.
Конкурентоспособность нового программного продукта по отношению к базовому можно оценить с помощью интегрального коэффициента конкурентоспособности, по формуле 5.4, учитывающего все ранее рассчитанные показатели.


(5.4)

где Кн – коэффициент соответствия нового программного продукта нормативам (Кн = 1);
Кц – коэффициент цены потребления (= 1).
Расчет уровня конкурентоспособности нового программного продукта приведен в таблице Б.3.
Коэффициент цены потребления рассчитывается как отношение договорной цены нового программного продукта к договорной цене базового (= 1).

Ки = (1,331,421)/1 = 1.89.

Интегральный коэффициент конкурентоспособности () больше 1, т.е. новый программный продукт является более конкурентоспособным, чем базовый.

5.3 Оценка трудоемкости работ по созданию программного 
обеспечения

В качестве единицы измерения объема ПО может быть использована строка исходного кода (LOC). Общий объем ПО (V0) определяется исходя из количества и объема функций, реализуемых программой, по каталогу функций ПО по формуле (5.5):

,	(5.5)

где Vi – объем отдельной функции ПО;
       n – общее число функций.
Уточненный объем ПО () определяется по формуле (5.6):

,	(5.6)

где  – уточненный объем отдельной функции ПО в строках исходного кода.
Результаты расчетов представлены в таблице Б.4.
Рассчитаем поправочные коэффициенты, учитывающие организационно-технические условия разработки ПО.
Разработанное в ходе выполнения дипломной работы программное обеспечение по своим характеристикам относится к первой категории сложности.
На основании принятого к расчету (уточненного) объема () и категории сложности ПО принимаем нормативную трудоемкость ПО выполняемых работ  = 134 чел.-дн.
Дополнительные затраты труда, связанные с повышением сложности разрабатываемого ПО, учитываются посредством коэффициента повышения сложности ПО (), который определяем по формуле (5.7): 

	,	(5.7)

где  – коэффициент, соответствующий степени повышения сложности; 
        – количество учитываемых характеристик.
Принимаем коэффициент повышения сложности ПО равным 1,12.
Влияние фактора новизны на трудоемкость учитывается путем умножения нормативной трудоемкости на соответствующий коэффициент, учитывающий новизну ПО (). Разработанная программа обладает категорией новизны В, а значение  = 0,63.
Степень использования в разрабатываемом ПО стандартных модулей определяется их удельным весом в общем объеме ПО. Коэффициент, учитывающий степень использования стандартных модулей в разработанном приложении равен = 0,9.
Программный комплекс разработан на языках Python и Java, а также части ПО взаимодействуют по локальной сети, что соответствует коэффициенту, учитывающему средства разработки ПО,  = 0,6.
Значение коэффициентов удельных весов трудоемкости стадий разработки ПО определяются с учетом установленной категории новизны ПО и приведены в таблице Б.5.
Нормативная трудоемкость ПО () выполняемых работ по стадиям разработки корректируется с учетом коэффициентов: повышения сложности ПО, учитывающих новизну ПО (), учитывающих степень использования стандартных модулей (), средства разработки ПО () и определяются по формулам:
    • для стадии технического задания по формуле (5.8)

;		(5.8)

    • для стадии эскизного проекта формуле (5.9) 

;	(5.9)

    • для стадии технического проекта формуле (5.10)

;	(5.10)

    • для стадии рабочего проекта формуле (5.11)

;	(5.11)

    • для стадии ввода в действие формуле (5.12)

,	(5.12)

где , , ,  и  – значения коэффициентов удельных весов трудоемкости стадий разработки ПО в общей трудоемкости ПО.
Общая трудоемкость разработки ПО () определяется суммированием нормативной (скорректированной) трудоемкости ПО по стадиям разработки по формуле (5.13):

	,	(5.13)

где n – количество стадий разработки;
       – нормативная (скорректированная) трудоемкость разработки ПО на i-й стадии, чел.-дн.
Результаты расчёта нормативной (скорректированной) трудоемкости разработки ПО приведены в таблице Б.5.Следовательно общая трудоёмкость равна:

чел.-дн.

Результаты расчетов по определению нормативной и скорректированной трудоемкости программного обеспечения по стадиям разработки и общую трудоемкость разработки ПО () представлены в таблице Б.6.

5.4 Расчет затрат на разработку программного продукта

В состав затрат на разработку ПП входят следующие статьи расходов:
    • затраты труда на создание ПП (затраты по основной, дополнительной заработной плате и соответствующие отчисления) ();
    • затраты на изготовление эталонного экземпляра ();
    • затраты на технологию (затраты на приобретение и освоение программных средств, используемых при разработке ПП; затраты на ПО, используемое как эталон) ();
    • затраты на машинное время (расходы на содержание и эксплуатацию технических средств разработки, эксплуатации и сопровождения) ();
    • затраты на материалы (информационные носители) ();
    • затраты на энергию, на использование каналов связи (для отдельных видов);
    • общепроизводственные расходы (затраты на управленческий персонал, на содержание помещений) ();
    • непроизводственные (коммерческие) расходы (затраты, связанные с рекламой, поиском заказчиков, поставками конкретных экземпляров) ().
Для расчета затрат на разработку (себестоимости) программного продукта определим необходимые параметры: тарифная ставка, ставка арендных платежей, стоимость ПК, стоимость кВт-час и занесем их в таблицу Б.7.
Суммарные затраты на разработку ПО (Зр) определяются по формуле (5.14): 

	.	(5.14)

Расходы на оплату труда разработчиков с отчислениями (Зтр) определяются по формуле (5.15):

	,	(5.15)

где ЗПосн – основная заработная плата разработчиков, руб.; 
 ЗПдоп – дополнительная заработная плата разработчиков, руб.; 
 ОТЧзп – сумма отчислений от заработной платы (социальные нужды, стра-хование от несчастных случаев), руб.
Основная ЗП разработчиков рассчитывается по формуле (5.16):

	, 	(5.16)

где Сср.час – средняя часовая тарифная ставка, руб./час; 
То – общая трудоемкость разработки, чел.-час; 
Кув – коэффициент, учитывающий доплаты стимулирующего характера, примем Кув = 1,6.
Средняя часовая тарифная ставка определяется по формуле (5.17):

	 ,	(5.17)

где  Счi – часовая тарифная ставка разработчика i-й категории, руб./час; 
ni – количество разработчиков i-й категории.
Часовая тарифная ставка определяется путем деления месячной тарифной ставки на установленный при восьмичасовом рабочем дне фонд рабочего времени (Fмес) (5.18):

	,	(5.18)

где См1 – базовая ставка специалиста;
 Тк1 – тарифный коэффициент.

 руб./ч.

Следовательно, можно вывести значение основной ЗП разработчиков, используя полученные данные о средней часовой тарифной ставки, общей трудоёмкости разработки и коэффициент доплат стимулирующего характера:

 руб.

Дополнительная заработная плата рассчитывается по формуле (5.19):

,	(5.19)

где Ндоп – норматив на дополнительную заработную плату разработчиков.

 руб.

Отчисления от основной и дополнительной заработной платы (отчисления на социальные нужды и обязательное страхование) рассчитываются по формуле (5.20):

,	(5.20)
где Hз.п – процент отчислений на социальные нужды и обязательное страхование от суммы основной и дополнительной заработной платы (Hз.п = 34%).

 руб.

 руб.

Затраты машинного времени (Зм.в) определяются по формуле (5.21):

	, 	(5.21)

где Сч – стоимость 1 часа машинного времени, руб./ч; 
Кт – коэффициент мультипрограммности, показывающий распределение времени работы ЭВМ в зависимости от кол-ва пользователей ЭВМ; Кт  = 1; 
tэвм – машинное время ЭВМ, необходимое для разработки и отладки проекта, ч.
Стоимость машино-часа определяется по формуле (5.22):

	,	(5.22)

где Зам – амортизационные отчисления за год, руб./год;
Зэ.п – затраты на электроэнергию, руб./год;
Зв.м – затраты на материалы, необходимые для обеспечения нормальной работы ПЭВМ (вспомогательные), руб./год;
Зт.р – затраты на текущий и профилактический ремонт ЭВМ, руб./год;
Зпр – прочие затраты, связанные с эксплуатацией ПЭВМ, руб./год;
Fэвм – действительный фонд времени работы ЭВМ, час/год.
Такие коэффициенты как ЗПоб (затраты на заработную плату обслуживающего персонала с учетом всех отчислений, руб./год) и Зар (стоимость аренды помещения под размещение вычислительной техники, руб./год) не будут учитываться при расчёте стоимости машино-часа, так как для разработки данного проекта не требуется помещение и обслуживающий персонал.
Сумма годовых амортизационных отчислений (Зам) определяется по формуле (5.24):

	,	(5.24)

где Зпрi – затраты на приобретение i-го вида основных фондов, руб;
 Kдоп – коэффициент, характеризующий дополнительные затраты, связанные с доставкой и наладкой оборудования, Kдоп = 13% от Зпр; 
 Зпрi / (1 + Kдоп) – балансовая стоимость ЭВМ, руб; 
 Намi – норма амортизации, %.

 руб.

Если за год амортизационные отчисления составляют 282,5 руб., то за 54,8 дней разработки составят 42,86 руб.
Стоимость электроэнергии, потребляемой за год, (Зэвм) определяется по формуле (5.25):

	,	(5.25)

где Мсум – паспортная мощность ПЭВМ, кВт; Мсум = 0,41 кВт;
Сэл  – стоимость одного кВт-часа электроэнергии, руб;
А – коэффициент интенсивного использования мощности, А=0,98.
Действительный годовой фонд времени работы ПЭВМ (Fэвм) рассчитывается по формуле (5.26):

	,	(5.26)

где Дг – общее количество дней в году; Дг = 365 дней; 
Двых, Дпр – число выходных и празд-ых дней в году, Двых + Дпр = 112 дней; 
Fсм – продолжительность 1 смены, Fсм = 8 часов; 
Ксм – количество рабочих смен ЭВМ, Ксм = 1; 
Кпот – коэффициент, учитывающий потери рабочего времени, связанные с профилактикой и ремонтом ЭВМ, примем Кпот = 0,2.

 ч в год.

С учётом, что срок разработки программного продукта составляет 54.8 дней, действительный фонд времени работы ПЭВМ составляет 243.07 ч.

 руб.

Следовательно, за 54,8 дней разработки расходуется 38,17 руб.
Затраты на материалы (Зв.м), необходимые для обеспечения нормальной работы ПЭВМ составляют около 1% от балансовой стоимости ЭВМ и определяются по формуле (5.27):

	,	(5.27)

где Зпр – затраты на приобретение (стоимость) ЭВМ, руб.; 
 Kдоп – коэффициент, характеризующий доп. затраты, связанные с доставкой, монтажом и наладкой оборудования, Kдоп = 12 – 13 % от Зпр; 
Км.з – коэффициент, характеризующий затраты на вспомогательные материалы (Км.з = 0,01).

 руб.

Затраты на текущий и профилактический ремонт (Зт.р) принимаются равными 5% от балансовой стоимости ЭВМ и вычисляются по формуле (5.28):

	,	(5.28)

где Kт.р – коэффициент, характеризующий затраты на текущий и профилактический ремонт, Kт.р = 0,05.

 руб.

Прочие затраты на эксплуатацию ПК (Зпр) состоят из амортизационных отчислений на здания, стоимости услуг сторонних организаций и составляют 5 % от балансовой стоимости. Вычисляются по формуле (5.29): 

	,	(5.29)

где Kпр – коэффициент размера прочих затрат, связанных с эксплуатацией ЭВМ (Kпр = 0,05).

 руб.

Для расчета машинного времени ЭВМ (tэвм в часах), необходимого для разработки и отладки проекта, следует использовать формулу (5.30):

	,	(5.30)

где tр.п – срок реализации стадии «Рабочий проект» (РП); 
 tвн – срок реализации стадии «Ввод в действие» (ВП); tр.п+tвн= 23,6; 
 Fсм – продолжительность рабочей смены, ч; Fсм = 8 ч; 
 Kсм – количество рабочих смен, Kсм = 1.

 

1.36 руб./ч.

 руб.

Расчет затрат на изготовление эталонного экземпляра (Зэт) осуществляется по формуле (5.31):

	,	(5.31)

где Kэт – коэффициент затрат на изготовление эталонного ПП, Kэт =0,05.

 руб.

Затраты на материалы (носители информации и прочее), необходимые для обеспечения работы ПЭВМ, рассчитываются по формуле (5.32):

	,	(5.32)

где Змат – затраты на приобретение ЭВМ, руб.; 
 Kдоп – коэффициент, характеризующий доп. затраты, связанные с доставкой, монтажом и наладкой оборудования, Kдоп = 12-13 % от Зприобр; 
 Kм.з – коэффициент, характеризующий затраты на вспомогательные материалы (Kм.з = 0,01).

 руб.

Общепроизводственные затраты (Зобщ.пр) определяются по формуле (5.33):

	,	(5.33)

где  Нобщ.пр – норматив общепроизводственных затрат.

 руб. за 54,8 дней.

Непроизводственные затраты рассчитываются по формуле (5.34):

	,	(5.34)

где Ннепр – норматив непроизводственных затрат.

 руб. за 54,8 дней.

Итого получаем суммарные затраты на разработку: 

 руб.

Результаты расчетов приведены в таблице Б.8.

5.5 Расчет договорной цены разрабатываемого программного продукта

Оптовая цена ПП определяется по формуле (5.35) и прибыль от реализации () по формуле (5.36):

	,	(5.35)

	,	(5.36)

где Зр – себестоимость ПО, руб. (Зр =  руб.); 
 Пр – прибыль от реализации ПП, руб.; 
 Ур – уровень рентабельности ПП, % (Ур = 30 %).

Таким образом, прибыль от реализации ПП для разработчика составит:

 руб. 

 руб. 

Расчёт отпускной цены ПП без НДС рассчитывается по формуле (5.37):

	,	(5.37)

где ,   – дополнительные налоги, руб. (= 0 руб., = 0 руб.).
Следовательно, отпускная цена без НДС равна оптовой цене.
Отпускная цена ПО с НДС рассчитывается по следующей формуле (5.38):

	,	(5.38)

где  – налог на добавленную стоимость, руб.
Налог на добавленную стоимость рассчитывается по следующей формуле (5.39):

	,	(5.39)

где  – ставка налога на добавленную стоимость, %,  = 20%.

 руб. 

 руб. 

Розничная цена на ПП () определяется по формуле (5.40):

	,	(5.40)

Где  – торговая наценка при реализации программного обеспечения через специализированные магазины (торговых посредников), её значение принимается в размере 10-20% от отпускной цены с НДС.

 руб. 

Результаты расчетов приведены в таблице Б.9.

5.6 Расчет частных экономических эффектов от производства и 
    использования программного продукта

Данный программный продукт нацелен на реализацию через специализированные магазины. В данном разделе была рассчитана цена, которую необходимо будет заплатить единожды специализированному магазину-покупателю ПП. В последующем специализированный магазин, владеющим программным продуктом сможет внедрять и продавать свой товар через приложение, тем самым окупив стоимость его приобретения за определённый срок.
Чистую прибыль от интеграции в программный продукт прямых ссылок на товары владеющей компании, можно рассчитать по формуле (5.41):

 ,                                         (5.41)

где  – количество пользователей в день, перешедших на страницу товара и купивших его;
 – средняя торговая наценка на потенциальный товар, размещаемый в приложении (10-20% от цены товара);
 – количество дней, равняется 30;
 – количество месяцев, равняется 12.
Количество активных пользователей за день, на основе данных о базовом продукте, в среднем равняется 60 чел. Допустим, что из данного числа пользователей около 10% перейдёт по ссылке на страницу интегрированного товара и приобретёт его. В гомельской области средняя цена краски для стен около 50 руб. за 10 л, средняя цена обоев составляет 40 руб. за рулон.
Таким образом, чистая прибыль за реализацию за 12 месяцев составит: 

руб.

Компания-владелец несёт затраты только за сопровождение программного продукта (), примем значение равным 30% от общего дохода, с учётом налогов и прочих выплат.
В первый год эксплуатации программного продукта компания инвестирует сумму, равную сумме розничной стоимости ПО и 30% от годового дохода приобретённого только за счёт эксплуатации ПО. Затраты на эксплуатацию и поддержку ПО можно рассчитать по следующей формуле (5.42):

 ,                                          (5.42)

Таким образом, инвестиции в первый год эксплуатации составят:

 руб. 

Таким образом, можно рассчитать сроки окупаемости ПП:

=  лет.

Технико-экономические показатели приведены в таблице Б.10.
По результатам рассчитанных показателей установлено, что реализация дипломной работы является экономически целесообразной.

    6 ОХРАНА ТРУДА И ТЕХНИКА БЕЗОПАСНОСТИ

        6.1 Однофазное и двухфазное включение человека в электрических сетях напряжением свыше 1 кВ

Электрические сети, по которым подается напряжение потребителю, делятся на сети с глухозаземлённой нейтралью и сети с изолированной нейтралью [15].
Под глухозаземленной нейтралью понимают нейтраль трансформатора или генератора, присоединенную непосредственно к заземляющему устройству. 
Изолированная нейтраль – это нейтраль трансформатора или генератора, не присоединенная к заземляющему устройству или присоединенная к нему через большое сопротивление приборов сигнализации, измерения, защиты и других аналогичных им устройств.
Режим нейтрали в трехфазных сетях выбирают по технологическим требованиям и по условиям безопасности, что прописано в нормативных документах. Согласно правил устройства электроустановок при напряжении до 1000 В (или 1 кВ) применяют четырехпроводную сеть с глухозаземленной нейтралью или трехпроводную сеть с изолированной нейтралью. 
При напряжении свыше 1000 В применяют трехпроводные сети с изолированной нейтралью и трехпроводные сети с эффективно заземленной нейтралью.
На производстве для электроснабжения силовых потребителей электрической энергии широко используются трехпроводные электрические сети с изолированной нейтралью. При такой электрической сети фазные провода по отношению к земле имеют емкость и активное сопротивление – сопротивление утечки. Это сопротивление равно сумме сопротивлений изоляции при прохождении тока от проводов на землю. 
Протекая через тело человека, электрический ток производит термическое, электролитическое, механическое и биологическое действия.
Тяжесть поражения электрическим током зависит от целого ряда факторов:
    • схемы замыкания цепи через тело человека; 
    • напряжения сети;
    • режима нейтрали (нейтраль изолирована или заземлена);
    • сопротивления тела человека;
    • степени изоляции токоведущих частей от земли;
    • значения ёмкости токоведущих частей относительно земли.
Следовательно, в одних случаях замыкание цепи тока через тело человека будет сопровождаться прохождением через него малых токов или окажется не опасным, а в других – токи могут достигать больших значений, способных вызвать смертельный исход [16].
Степень опасности поражения человека электрическим током зависит в значительной мере от того, каким оказалось включение человека в электрическую цепь. Наиболее типичными являются два случая замыкания цепи через тело человека:
    • прикосновение к одной фазе элек­троустановки, находящейся под напряжением (однофазное включение); 
    • одновременное прикосновение к двум фазам электроустановки, находящейся под напряжением (двухфазное включение).
Более опасным случаем поражения человека электрическим током является случай, когда человек может одновременно коснуться двух фазных проводов, как показано на рисунке 6.1. 
При двухфазном прикосновении ток, проходящий через тело человека практически не зависит от режима нейтрали сети, следовательно, двухфазное прикосновение является одинаково опасным как в сети с изолированной, так и с заземлённой нейтралью. 
При двухфазном включении опасность поражения не уменьшится и в случае, если человек будет надёжно изолирован от земли. 



Рисунок 6.1 – Схема двухфазного включения в сеть человеком

В случае двухфазного включения человек попадает одновременно под линейное Uл и под фазное Uф напряжения. Через тело человека потечет ток как от одного фазного провода к другому по схеме рука-рука, так и от каждого фазного провода на землю по схеме рука-нога.
Поскольку в трехфазных сетях линейное напряжение связано с фазным соотношением (6.1):

,
(6.1)

где Uл – линейное напряжение, В;
 Uф – фазное напряжение, В.
Линейное напряжение будет всегда больше фазного, и, учитывая, что человек обычно находится в обуви, наиболее опасным будет ток, протекающий от одной фазы через тело человека к другой фазе по схеме рука-рука.
Но при этом, случаи двухфазного включения человека редки и являются, как правило, результатом нарушения правил техники безопасно­сти.
Если человек коснется одного из фазных проводов, как показано на рисунке 6.2, то ток протечёт через изоляцию, емкость проводов, тело человека по схеме рука-нога, обувь человека и землю. 



Рисунок 6.2 – Схема касания человеком фазного провода в сети с изолированной нейтралью

Протекающий ток будет стекать на два других фазных провода. При этом создается замкнутая электрическая цепь, в которую также включено сопротивление изоляции проводов.
В отличии от сетей с глухозаземлённой нейтралью, в сетях с изолированной нейтралью, факт добавления сопротивления изоляции проводов, существенно снижает силу проходящего тока через тело человека.
Сопротивление исправной изоляции проводов составляет сотни кОм, поэтому значение величины протекающего тока будет весьма незначительным и не представляющим опасности для человека. Данное значение можно рассчитать по формуле (6.2):

,
(6.2)

где Rцч = Rч  + Rоб  + Rос – электрическое сопротивление цепи протекания тока через человека, Ом; 
w = 2nf – круговая частота тока в электрической сети, рад/с (для тока промышленной частоты f = 50 Гц);
C – емкость проводника.
Сети большой протяженности с изолированными проводами, обладающие большой емкостью, а следовательно, и большим емкостным током, могут представлять для человека серьезную опасность.
Для коротких воздушных сетей обычно емкость фаз невелика, и при расчетах ею пренебрегают, то есть принимают С = 0.





    • 
    7 РЕСУРСО- И ЭНЕРГОСБЕРЕЖЕНИЕ ПРИ ВНЕДРЕНИИ ПРОГРАММНОГО ОБЕСПЕЧЕНИЯ

        7.1 Вопросы ресурсосбережения, связанные с внедрением программного обеспечения

Республиканским органом государственного управления, уполномоченным Правительством Республики Беларусь для проведения государственной политики в сфере энергосбережения, является Комитет по энергоэффективности при Совете Министров Республики Беларусь. Основными задачами Комитета по энергоэффективности при Совете Министров Республики Беларусь являются проведение государственной политики в сфере энергосбережения и осуществление государственного надзора за рациональным использованием топлива, электрической и тепловой энергии.
Техническое регулирование, выполнение программ, проведение контроля и прочие оперативные функций в области эффективного использования топливно-энергетических ресурсов и энергосбережения выполняет Департамент по энергоэффективности Государственного комитета по стандартизации РБ.
Ресурсосбережение – совокупность мер по бережливому и эффективному использованию фактов производства (капитала, земли, труда). Обеспечивается посредством использования:
    • ресурсосберегающих и энергосберегающих технологий;
    • снижения фондоемкости и материалоемкости продукции;
    • повышения производительности труда;
    • сокращения затрат живого и овеществленного труда;
    • повышения качества продукции;
    • рационального применения труда менеджеров и маркетологов; 
    • использования выгод международного разделения труда. 
Ресурсосбережение и энергосбережение способствует росту эффективности экономики, повышению ее конкурентоспособности [17].
ГОСТ 30166-2014 «Ресурсосбережение. Основные положения» является действующим стандартом. Является основополагающим и устанавливает цель, задачи, объекты, основные принципы, термины и классификацию групп требований рационального использования и экономного расходования материальных ресурсов на всех стадиях жизненного цикла веществ, материалов, изделий, продукции при проведении работ и оказании услуг юридическим и физическим лицам.
Настоящий стандарт распространяется на все виды деятельности, связанные с добычей, переработкой, транспортированием, хранением, распределением и потреблением материальных ресурсов.
Экономия ресурсов, связанная с внедрением разработанного программного обеспечения, заключается в сокращении потребления отделочных материалов на душу населения. Производство такого товара как краска для стен не только тратит энергетические ресурсы, но и является загрязняющим для окружающей среды, при содержании в составе определённых веществ (формальдегиды, фталаты) [18].
Разработанный программный комплекс в первую очередь нацелен на сокращение приобретённых пользователем отделочных и покрасочных продуктов, таких как краска для стен, обои. Продукт позволяет предварительно «окрасить» помещение, для того, чтобы не ошибиться с выбором материала в дальнейшем. Также программный продукт поддерживает покупку товара через сеть, что потенциально сокращает численность персонала физических магазинов, а также экономит время покупателю. Программный комплекс может быть полезен в точном подсчёте литров краски или рулонов обоев для стен пользователя, что также сокращает приобретение лишнего товара.
Ниже представлена формула расчёта экономии расходов (краска, обои) по формуле:

					(7.1)

где К – коэффициент сокращения остальных расходов;
      – среднемесячная заработная плата пользователей, руб.;
      n – количество рабочих;
       – остальные расходы, в процентах.         
Статистическая медианная заработная плата жителя Беларуси по состоянию на 26 мая 2021 года составляет 944,4 рубля [19]. Остальные расходы принимаем равным 5%. Коэффициент сокращения равен 0,5. Количество пользователей n=1.

 руб.

По результатам проведенной оценки установлено, что внедрение нового программного продукта является целесообразно, так как присутствует экономия энергоресурсов для завода-производителя и для пользователя продукта на отделочно-покрасочных материалах.

        7.2 Экономия энергоресурсов в результате внедрения программного обеспечения

Энергосбережение сегодня – одно из приоритетных направлений экономической политики предприятий, ориентированных на динамичное развитие, как в плане снижения издержек на производство основной продукции, так и, в соответствии с общей направленностью правительственных программ, направленных на снижение нагрузок на вырабатывающие мощности [20].
Эффекты от мероприятий энергосбережения рассчитывают:
    • как стоимость сэкономленных энергоресурсов или доля стоимости от потребляемых энергоресурсов, в том числе на единицу продукции;
    • как количество тонн условного топлива сэкономленных энергоресурсов или доля от величины потребляемых энергоресурсов;
    • в натуральном выражении (кВт∙ч, Гкал и т. д.);
    • как снижение доли энергоресурсов в валовом внутреннем продукте в стоимостном выражении, либо в натуральных единицах на 1 руб. валового внутреннего продукта.
Так как разработанное программное обеспечение охватывает широкий круг вычислительных машин, способных работать с данным продуктом, то подсчёт точного экономического эффекта от сбережения электроэнергии, при внедрении разработанного ПО затруднителен. Кроме того, объемы данных, которыми будет оперировать приложение, в ходе эксплуатации, также имеют размытые границы.
Ниже производится расчёт экономии электрической энергии при работе программного продукта по следующей формуле:

,			 	 (7.2)

где – трудоемкость работы вручную, часов;
      – трудоемкость работы с помощью ПО, часов;
       – паспортная мощность вычислительной машины, кВт (М = 0,5 кВт);
      – стоимость одного кВт∙ч электроэнергии, руб;
      – коэффициент использования устройства (= 0,01).
Окраски стен вручную на ПК занимает около 20 минут для одного человека, с учётом наложения текстур обоев и прочих косметических операций. Для той же операции с применением разработанного ПО требуется около 1,44 секунды. 
По состоянию на 26 мая 2021 года стоимость 1 кВт∙ч электроэнергии в Республике Беларусь для юридических лиц равен 0,2059 рубля [21]. 
Соответственно, стоимость сэкономленной электроэнергии за один месяц при пятидневной рабочей неделе и восьмичасовом рабочем дне составит:

 руб.

Данный расчет показывает, что при внедрении разработанного программного продукта можно сэкономить на электроэнергии 414,6 рубля в месяц, а за год 4975,16 рублей.





